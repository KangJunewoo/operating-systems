# RR 스케줄링

## 부모프로세스
* 자식프로세스 10개 만든다.
* 타임퀀텀은 마음대로 잡는다.
* 부모는 alarm signal을 주기적으로 받는다.
* 런큐, 대기큐 있어야 한다.
  * 런큐 : 레디상태인 자식프로세스 담는다
  * 대기큐 : 레디X상태인 자식프로세스 담는다
* 부모는 자식을 스케줄링한다.
* 부모는 자식에게 메세지큐를 통해 ipc 메세지를 보낸다.
* msgget, msgsnd, msgrcv
* ipc_nowait 플래그 사용.


## 자식프로세스
* cpu burst time은 랜덤으로 생성됨.
* 뭔가 프로세싱 되는 걸 ipc메세지를 통해 부모한테 받는 것 같고, 그 때 cpu burst value 를 줄이면 되는 것 같다.




## 결과물은
* 어느 타임에, 프로세스가가 cpu 시간, 남은 burst time을 가지고
* schedule_dump.txt / 
* 각 프로세스는 최소 1분은 돌아야 한다.

## issues
* 부모에서 자식 10개 만드는 것은 완료
* 하지만 기존 방식은
  1. 부모가 자식을 만들고
  2. 자식이 종료되고
  3. 이게 10번 반복이 되었다.
* 기존 방식을 개선해 다음 방식을 할 수 있지만 어렵다.
  1. 부모가 자식을 만들고
  2. 자식이 부모에게 자기 pid, arrivaltime, bursttime 넘겨주고
  3. 자식이 종료되고, 이게 열 번 반복이 된 후 본격적으로 부모에서 스케줄링 시작
* 생각을 바꿔 한 부모가 10개의 pid를 만들 수 있다면?
  1. 재귀를 통해 자식 pid를 아싸리 10개 만들고
  2. 근데 재귀를 해도 어차피 먼저 종료되는 건 똑같다.

* 자식은 부모에게 메세지큐를 통해 정보를 전달할 수 있다.
  * 근데 지난번엔 다른 파일로 해서 ㄱㄴ했던 거고
    * 다른파일이어도 한 컴퓨터 내에서 동시에 프로세스가 실행되는 거니까 ㄱㅊ.
  * 지금은 같은 파일인데
    * 다른 프로세스 도는거니까 조건만 맞추면 ㄱㅊ지 않을까.


## 벼락치기로 해볼..
* 메세지큐로 자식->부모 메세지 사용할 수 있는지 확인
  * 있다면 pcb 생성까지만 ipcmessage 활용한다.
  * fork로 부모가 자식프로세스 10개 만드는 건 성공했고
  * 자식프로세스는 부모프로세스한테 pcb값을 넘겨주었으며
  * 그 정보를 가지고 라운드로빈 스케줄링을 진행했습니다.
* 없다면,, 절충안으로 간다.
  * fork로 부모가 자식프로세스 10개 만드는 건 성공했습니다만
  * 실제 자식프로세스의 정보를 ipc메세지를 통해 전달하는 것에 성공하진 못했습니다.
  * 대신 임의의 PCB 10개를 통해 스케줄러를 구현했습니다.

## 메세지큐
* msg_type -> 이걸 고유값으로 해야 10번의 리시브가 가능할듯.
* 김재는 했으니 메세지큐 사용하는 것까지만 꼭 해보자.